#!/usr/bin/env bash
set -e

if [ -z "$1" ] || [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    echo "Usage:"
    echo "  gh q get <repo>     ... Clone a repository into ~/ghq/github.com"
    echo "  gh q list           ... List all repositories in ~/ghq/github.com"
    echo "  gh q clean [--days N] [--dry-run]"
    echo "                     ... Per-repo cleanup: if repo inactive for N days (default 15), remove generated artifacts inside it"
    echo "  gh q -- <command>   ... Search via fzf and run <command> in the selected directory"
    echo "  gh q <command>      ... Search via fzf and run <command> with selected directory as argument"
    exit 0

# gh q get
elif [ "$1" == "get" ]; then
    if [[ "$2" == git@github.com:* || "$2" == https://github.com/* ]]; then
        # ex: git@github.com:owner/repo.git → owner/repo
        # ex: https:github.com/owner/repo.git → owner/repo
        repo_name=$(echo "$2" | sed -e 's/.*github.com[:\/]\(.*\)\.git/\1/')
        repo_path="$HOME/ghq/github.com/${repo_name}"
    else
        repo_path="$HOME/ghq/github.com/$2"
    fi

    if [ ! -d "$repo_path" ]; then
        gh repo clone "$2" "$repo_path"
    else
        echo "Repository already exists at $repo_path"
    fi


# gh q list
elif [ "$1" == "list" ]; then
    find ~/ghq -maxdepth 3 -mindepth 3 -type d -not -path '*/\.*' -not -path '*/.git/worktrees*'


elif [ "$1" == "clean" ]; then
    shift
    DAYS=15
    DRY_RUN=0
    while [ $# -gt 0 ]; do
        case "$1" in
            --days)
                if [ -n "$2" ] && [[ "$2" =~ ^[0-9]+$ ]]; then
                    DAYS="$2"; shift 2
                else
                    echo "Error: --days requires an integer argument" >&2; exit 1
                fi
                ;;
            --dry-run)
                DRY_RUN=1; shift ;;
            -h|--help)
                echo "Usage: gh q clean [--days N] [--dry-run]";
                echo "  Cleans generated artifacts under ~/ghq older than N days (default 15).";
                echo "  Targets: node_modules, dist, build, out, .next, .nuxt, .cache, .gradle, .terraform, target, .venv, venv, .tox, __pycache__, .pytest_cache, .mypy_cache, coverage, .parcel-cache, .yarn/cache, .yarn/unplugged, Pods";
                exit 0 ;;
            *)
                echo "Unknown option: $1" >&2; exit 1 ;;
        esac
    done

    ROOT="$HOME/ghq"
    if [ ! -d "$ROOT" ]; then
        echo "Not found: $ROOT" >&2; exit 1
    fi

    TARGETS=(
        node_modules
        dist
        build
        out
        .next
        .nuxt
        .cache
        .gradle
        .terraform
        target
        .venv
        venv
        .tox
        __pycache__
        .pytest_cache
        .mypy_cache
        coverage
        .parcel-cache
        Pods
        .yarn
    )

    name_expr=()
    for n in "${TARGETS[@]}"; do
        if [ ${#name_expr[@]} -gt 0 ]; then
            name_expr+=( -o )
        fi
        if [ "$n" = ".yarn" ]; then
            name_expr+=( \( -path "*/.yarn/cache" -o -path "*/.yarn/unplugged" \) )
        else
            name_expr+=( -name "$n" )
        fi
    done

    # Compute cutoff epoch: now - DAYS*86400 (portable)
    NOW_EPOCH=$(date +%s)
    CUTOFF_EPOCH=$(( NOW_EPOCH - DAYS * 86400 ))

    # Helper to get repo last activity epoch
    get_repo_epoch() {
        local repo="$1"
        local ts=""
        ts=$(git -C "$repo" log -1 --format=%ct 2>/dev/null || true)
        if [ -n "$ts" ]; then
            echo "$ts"; return 0
        fi
        # Fallback to directory mtime (BSD/GNU stat)
        if stat -f %m "$repo" >/dev/null 2>&1; then
            stat -f %m "$repo"
        elif stat -c %Y "$repo" >/dev/null 2>&1; then
            stat -c %Y "$repo"
        else
            echo 0
        fi
    }

    echo "Scanning $ROOT repositories; cleaning those inactive for $DAYS days..."

    REPOS_CLEANED=0
    DIRS_REMOVED=0

    # Reuse gh q list to enumerate repos
    while IFS= read -r repo; do
        [ -z "$repo" ] && continue
        [ -d "$repo/.git" ] || continue
        last_epoch=$(get_repo_epoch "$repo")
        # If last activity newer than cutoff, skip repo
        if [ "$last_epoch" -ge "$CUTOFF_EPOCH" ]; then
            continue
        fi

        # Build list of target directories within this repo
        mapfile -t candidates < <(eval find "\"$repo\"" -type d \( ${name_expr[@]} \) -prune -print)
        if [ ${#candidates[@]} -eq 0 ]; then
            continue
        fi

        REPOS_CLEANED=$((REPOS_CLEANED+1))
        if [ $DRY_RUN -eq 1 ]; then
            echo "Repo (inactive): $repo"
            for d in "${candidates[@]}"; do
                echo "  would remove: $d"
            done
        else
            echo "Repo (inactive): $repo"
            for d in "${candidates[@]}"; do
                echo "  removing: $d"
                rm -rf "$d"
                DIRS_REMOVED=$((DIRS_REMOVED+1))
            done
        fi
    done < <(gh q list)

    if [ $DRY_RUN -eq 1 ]; then
        if [ $REPOS_CLEANED -eq 0 ]; then
            echo "No inactive repositories found for cleanup."
        else
            echo "Dry-run complete. $REPOS_CLEANED repos would be cleaned."
        fi
    else
        if [ $REPOS_CLEANED -eq 0 ]; then
            echo "No inactive repositories found for cleanup."
        else
            echo "Cleanup complete. Cleaned $REPOS_CLEANED repos, removed $DIRS_REMOVED directories."
        fi
    fi


# gh q -- <command>
elif [ "$1" == "--" ]; then
    shift  # Remove the "--" from arguments
    selected_dir=$(gh q list | fzf)
    if [ -n "$selected_dir" ]; then
        cd "$selected_dir"
        if [ $# -eq 0 ]; then
            exec "$SHELL"
        else
            exec "$@"
        fi
    fi

# gh q <command>
else
    selected_dir=$(gh q list | fzf)
    if [ -n "$selected_dir" ]; then
        exec "$@" "$selected_dir"
    fi
fi
